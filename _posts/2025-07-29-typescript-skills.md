---
layout: post
title: "[나의 첫 타입스크립트 프로젝트] Chapter 4."
description: "TypeScript Skills"
date: 2025-07-29
feature_image: images/book-typescript-4.png
tags: [나의 첫 타입스크립트 프로젝트, typescript, book, review]
---

# Chapter 4. 타입스크립트 스킬

자바스크립트에서는 변수에 어떤 값이든 할당할 수 있지만, 타입스크립트는 변수에 타입을 정하고 지정된 타입의 값만 할당할 수 있다. 🎉 이 얼마나 기쁜 소식인가! 

그 옛날, 자바스크립트를 만질 때 한 변수에 타입 관계없이 막 저장했다 바꿨다 하는 것을 보면서 "근본없는 언어"라고 (나 혼자) 목 놓아 울부짖던 때가 주마등처럼 스쳐간다. 

<!--more-->

## 4.1 타입 추론과 타입 주석

**타입 추론<sub>Type Inference</sub>**은 개발자가 명시적으로 타입을 지정하지 않아도, 컴파일러가 코드의 문맥을 분석하여 자동으로 변수, 매개변수, 반환값 등의 타입을 결정하는 기능이다.
타입 추론을 활용하면 코드의 가독성을 높이고, 더욱 간결하게 코드를 작성할 수 있다.

하지만 모든 경우에 대해 타입을 추론할 수 있는 건 아니어서, 개발자가 타입을 직접 명시해야 하는 경우도 자주 발생한다. 이것을 **타입 주석<sub>Type Annotation</sub>**이라고 한다.

### 4.1.1 타입 추론

다음의 코드를 먼저 보자.
```javascript
let val = "this is a string";
val = 123;

console.log(val);
```
만약에 자바스크립트였다면, 콘솔에 `123`이라고 출력되었으리라. 다시 생각해봐도 '근본없는 언어'가 아닐 수 없다.
그런데, 위의 코드를 타입스크립트 컴파일(?)을 하면 다음과 같은 메시지가 출력된다.

```bash
index.ts:7:1 - error TS2322: Type 'number' is not assignable to type 'string'.
```
메시지를 해석하면, '*number 타입은 string 타입에 할당할 수 없다.*'는 에러다. 그렇지! 이래야 프로그래밍 언어지! 😆

개발자가 `val` 변수에 문자열을 할당했기 때문에 타입스크립트는 해당 변수를 `string` 타입이라고 추론하는데 `number` 값을 다시 할당하려고 하는 코드에 에러를 표시한다.

### 4.1.2 타입 주석

```javascript
const str: string = "string";
const bol: boolean = true;
const num: number = 42;
const arr: string[] = ["one", "two", "three"];
const obj: { key: string; value: number } = { key: "example", value: 100 };
```
위의 예제 코드와 같이 변수명 다음에 `: <타입>`을 지정하면 된다.

## 4.2 함수 타입

함수도 마찬가지로 타입을 명시할 수 있다.

```javascript
function 함수명(매개변수명: <타입>, 매개변수명: <타입>): <반환 타입> {
  // 실행 로직
  
  return 반환 타입에 맞는 반환 값(또는 변수명)
}
```
위의 문법에서 보듯이 `: <타입>`을 지정하여 타입을 함수에도 지정할 수 있다.

타입스크립트는 함수형 프로그래밍이 지원되기 때문에 함수를 변수에 할당할 수 있다.

```javascript
const 변수명: Function = (매개변수명: <타입>, 매개변수명: <타입>): <반환 타입> => {
  // 실행 로직
  
  return 반환 타입에 맞는 반환 값(또는 변수명)
};
```
예제처럼 `Function` 타입을 명시하여 해당 변수가 함수임을 알 수 있게 할 수도 있다.

## 4.3 enum 타입

`enum`은 열거형을 정의하기 위한 타입이다. 다음의 예제 코드를 보자.

```javascript
enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE",
}
```
열거형은 대문자로 시작한다. 이게 타입스크립트의 명명 규칙<sub>naming convention</sub>인지 모르겠지만, VSCode는 저렇게 자동으로 해준다. IDE가 그렇게 한다면... 나름의 어떤 이유가 있겠지? 

## 4.4 ~ 4.6 인터페이스, 클래스, 제네릭

이 부분은 그냥 글로 정리해본다.

**객체 지향 언어<sub>Object Oriented Language</sub>**를 접할 때면 항상 나오는 개념이다. **클래스<sub>class</sub>**는 객체에 대한 설계도<sub>blueprint</sub>라고 할 수 있다.
클래스 설계를 하다보면 유사한 클래스들이 발견되며 이것을 **상속<sub>inheritance</sub>**을 통해 상위/하위 클래스를 나누고 어떤 **속성<sub>property</sub>**이 어느 클래스에 속해야 하는지를 나뉘게 된다.
이러다 보니, 여러 상위 클래스의 특징을 그대로 받아야 하는 하위 클래스가 생겼고, 어떤 언어는 여러 상위 클래스로부터 상속받을 수 있게 하는 **다중 상속<sub>multiple inheritance</sub>**을 허용하기도 했다.
어떤 언어에서는 다중 상속이 객체 지향 언어에 맞지 않다고 하여 금지하곤 했다. 이 싸움이 어떻게 끝났는지는 모르지만, '다중 상속' 개념이 점점 없어지는 거 보니 허용하지 않는 분위기로 흐르는 듯 하다.
참고로, 타입스크립트도 다중 상속이 안된다!

어쨌든, 다중 상속은 안하면서 '다중 상속'스러운(?) 기능이 필요했고 그것이 바로 **인터페이스<sub>interface</sub>**다.
여러 상위 클래스로부터의 다중 상속은 안되지만, 여러 인터페이스를 추가할 수는 있다.

**제네릭<sub>generic</sub>**은 코드 재사용성을 극대화하기 위해 생긴 개념이다.
객체 지향 언어는 기본적으로 **오버로딩<sub>overloading</sub>**과 **오버라이딩<sub>overriding</sub>**을 지원한다.
그런데, 예를 들어, 매개변수 타입 별로 동일한 이름의 함수를 만들려고 하다보니 같은 메서드(함수)를 여러 개 만들게 되는 현상이 발생했다.
그래서 나온 아이디어가 해당 메서드(함수)를 호출하는 곳에서 타입을 지정할 수 있도록 하고, 해당 메서드 안에서는 타입에 따라 처리하는 코드를 넣으면 한 곳에서 코드가 관리될 수 있다는 아이디어가 생겼다.
이렇게 하면, 불필요하게 반복되는 코드를 만들 필요도 없고 디버깅과 코드 관리도 좋아진다.

## 후기
이번 장은 **객체 지향 언어**로서의 타입스크립트를 설명한 듯 하다. 개인적으론 스크립트 언어가 객체 지향을 표방한다고 해도 한계가 있다고 생각한다.
타입스크립트가 얼마나 대단한지 아직 잘 모르지만, 스크립트 언어가 나에게 주는 선입견(?)이랄까? 그런 게 있다.
이번 장을 읽으면서, '아~ '객체 지향'스러워지려고 노력을 많이 했구나?'하는 느낌은 받았다. 그래도... 마음 한 켠에는 '그래봤자 스크립트 언어 아닌가?'하는 앙금(?)이... 😅









